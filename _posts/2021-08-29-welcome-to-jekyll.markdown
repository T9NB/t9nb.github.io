---
layout: post
title: "JavaScript 번들 또는 변환이 없는 최신 웹 앱"
date: 2021-08-29 16:15:16 +0900
categories: javascript
---

나는 ES6 이전에는 바닐라 자바스크립트를 별로 좋아하지 않았다. ES6 이전에는 바닐라 JavaScript를 별로 좋아하지 않았다. 2000년대 내내 너무 많은 글을 쓰지 않기 위해 다양한 접근 방식을 추구했다. 먼저 RJS(Ruby-to-JavaScript)가 있었다. 그 다음에 CoffeeScript가 있었고. 두 가지 모두 쓰기 쉬운 소스 코드를 브라우저에서 실행할 수 있는 JavaScript 종류로 변환하는 접근 방식이다. 꽤 효과가 있었다.

하지만 그것은 분명히 마수였다. 브라우저가 JavaScript를 더 잘 이해하기를 기다리는 동안 잠시의 공백. 한동안은 그런 일이 없을 것 같았지만, 우린 영원히 이 손아귀에 갇히게 될지도 몰랐다!

다행스럽게도 그렇지 않았다. JavaScript가 발전하고 있었고, 2015년에는 ES6라는 거대한 점프가 완성되었다. 그 이전과 그 이후는 Babel transpiler가 미래의 JavaScript를 작성하게 했다.

그것은 계시였다. 이렇게 훨씬 더 나은 JavaScript를 사용하여 프로그래밍할 수 있었던 것은 광범위한 브라우저 지원을 받기 훨씬 이전이었다. 바람피우는 기분이었다. 공짜로 뭔가를 얻은 것처럼... 하지만 그것은 옳지 않았다.

Babel을 사용한 변환은 끔찍할 정도로 복잡한 변환 파이프라인과 툴링의 시대를 이끌었다. 미래의 JavaScript를 작성하는 것은 무료가 아니었다. 그 가격은 계속 증가하는 복잡성의 거미줄이었다. 이건 분명히 결승선이 아니었다.

그래도 웹팩과 같은 툴이 이러한 전환을 가능하게 해줘서 고맙다. 복잡함에도 불구하고, 그것은 흥정할 가치가 있다고 느꼈다. 2016년에는 Webpacker를 만들었고 2017년에는 Rails 5.2를 출시했다. Rails는 이러한 방식으로 JavaScript를 Rails와 함께 관리할 수 있었다.

5년이 지난 지금, 현실이 마침내 바뀌었다. 나는 더 이상 이 거래가 대부분의 새로운 응용 프로그램에게 가치가 있다고 생각하지 않는다. 막다른 골목은 아니며, 여전히 제대로 작동하는 특정 유형의 응용 프로그램이 있지만(Hello React!) 더 이상 Rails에 적합한 기본값은 아니다.

첫 번째 중요한 변화는 ES6가 현재 중요한 모든 브라우저에서 지원된다는 것이다. Chrome, Edge, Safari 및 Firefox는 ES6를 완전히 지원한다. 마지막 주요 버티기는 IE11이었지만 마이크로소프트는 자비롭게도 올해 수명을 다했다고 발표했다.

따라서 ES6를 브라우저에서 실행할 수 있는 기능으로 전환하기 위해 번거로운 단계가 필요하지 않다. 변경 없이 잘 작동한다. 엄청나게도!

두 번째 중요한 변화는 HTTP2가 이제 표준이라는 것이다. HTTP2를 사용하면 하나의 큰 파일 대신 많은 작은 파일을 보내는 데 성능 저하가 발생하지 않는다. 한 번의 연결로 필요한 모든 응답을 멀티플렉싱할 수 있다. 더 이상 다중 연결을 관리하고 여러 SSL 핸드셰이크 비용을 지불하지 않아도 된다. 즉, 모든 JavaScript를 단일 파일로 번들링하면 성능상의 이점이 상당 부분 사라진다(그래, 그래, 트리 쉐이킹은 여전히 있지만).

사실, 단일 빅 번들 패턴은 개발자의 인체공학뿐만 아니라 여러 면에서 더 나빠졌다(예: 긴 번들링 시간!). 모든 JavaScript 모듈을 단일 파일에 번들로 묶으면 모든 모듈을 변경하면 전체 번들이 만료된다. 브라우저가 모든 것을 새로 다운로드하도록 강제하고 모든 것을 다시 구문 분석한다. 완전 별로다.

각 모듈을 별도로 두면 모듈이 독립적으로 만료될 수 있다. 20개의 모듈이 있고 변경 사항이 하나만 있으면 나머지 19개는 캐시된 상태로 남아 있다. 이것이 바로 성능 매니아들이 갈망하는 캐싱 다이내믹스다.

그러나 전반적인 논점에 있어 더 이상 성능을 위해 번들이 필요하지 않은 경우 번들을 완전히 제거할 수 있다. 각 모듈을 자체 파일로 브라우저에 직접 제공하기만 하면 된다.

우리가 어디로 가는지 보이는가? 사용자를 미소짓게 하는 JavaScript 종류를 작성하기 위해 파일링을 할 필요도 없고 모든 모듈을 패키지로 묶을 필요도 없다. 통합: 소스 코드를 다른 것으로 바꾸기 위해 JavaScript 도구 체인이 필요하지 않다. 모든 종류의 복잡성이 벼랑 끝에 서 있다.

패러다임 고개를 넘어 두 가지 중요한 변화를 추진하는 마지막 요소는 import 맵이다. 명시적 파일 참조 대신 ES6(ESM이라고도 함)의 모듈에 대한 논리적 참조를 사용할 수 있다. 명시적 파일 참조의 문제는 다이제스트 스탬프 파일 이름을 가진 장수명 캐시의 표준 접근 방식과 잘못 페어링된다는 것이다.

`main-a6d26cef87d241eba5fa.js`와 같은 파일 이름이 표시되면 마지막 비트는 전체 파일의 요약이다. 해당 파일에 대해 고유하므로 파일의 항목을 변경하면 다이제스트도 변경된다. 즉, 파일은 변경되지 않으므로 브라우저에서 다이제스트로 영원히 캐시하도록 지정할 수 있다. 변경되면 새 파일 이름이 생성된다. 이는 사용자가 제어하는 캐시 만료 역학을 통해 우수한 성능을 얻으려면 매우 중요하다.

그러나 `import { Controller} from './javascript/stimulus-a6d26cef87d241eba5fa.js'` 같은 구문을 50개의 파일이 가지고 있다고 가정해 보라. 그건 끔찍할 것이다. "Stimulus"의 의존성을 변경할 때마다 각 파일을 업데이트해야 한다. 그러면 모든 파일이 개별적으로 만료되어버릴 것이다.

이 문제에 대한 답은 import 맵이라고 하며, 이미 Chrome과 Edge에 탑재된 기능이다. 파이어폭스도 고려중이라고 밝혔다. 사파리는 아직 언급이 없지만 ESM을 지원하는 모든 브라우저(ES6을 지원하는 모든 브라우저)에 대해 가져오기 맵을 지원하는 완벽하게 작동 가능한 [Shim](https://developer.mozilla.org/en-US/docs/Glossary/Shim)이 있다.

import 맵을 사용하여 import 의존성의 지도를 정의한다. 따라서 `./javascript/stimulus-a6d26cef87d241eba5fa.js` 대신 단순히 `stimulus`를 사용하고, import 맵에 `"stimulus": './javascript/stimulus-a6d26cef87d241eba5fa.js'`로 표시한다. Stimulus를 갱신할 때 맵을 바꾸기만 하고 참조는 바꾸지 않아도 된다. 어떤가?

import 맵을 손으로 유지하는 것은 여전히 좀 번거롭기 때문에, Rails의 경우 새로운 importmap-rails gem을 만들었. 이 gem은 프로그래밍 방식으로 맵을 구축하고 Shim을 포함하므로 모든 브라우저에서 사용할 수 있다. 이 gem은 Sprockets의 오래된 충실한 자산 파이프라인 엔진에 의존하여 다이제스트 작업을 수행한다. 완전한 패키지이다.

트랜스파일러 및 번들러가 없는 진행의 주요 요소를 파악하여 생성된 import 맵과 페어링하면 이제 노드를 로컬로 설치하여 최신 웹 애플리케이션을 만들 필요도 없는 환경을 구축할 수 있다.

Stimulum과 Turbo 모두 Rails용 Hotwire gem은 이미 이 설정에 의존하도록 변경되었다. gem은 프로그램 액세스를 사용하여 뒤에서 import 맵을 설정하므로 application.js에서는 모듈을 직접 가져올 수 있다.

이 복잡한 거대한 종양을 잘라내는 것이 개발 경험에 어떤 변화를 가져다 주는지 전달하기 어렵다. 새로운 삶을 사는 기분이다. 그러나 아직 해결이 필요한 의문이 있다.

첫 번째는 JSX용 컴파일에 의존하는 React와 같은 특정 인기 프레임워크가 아직 작동하지 않는다는 것이다. 명시적 트랜스파일링 또는 컴파일 단계가 필요한 모든 것은 분명히 트랜스파일러나 컴파일러를 필요로 한다. 그리고 다시 원점으로 돌아온다.

둘째, Hotwire는 Rails의 JavaScript와 함께 Action Text, Active Storage, Action Cable과 같은 기능을 Ruby gems와 애셋 파이프라인을 통해 제공할 수 있지만, 여전히 더 나은 답이 필요한 대규모 JavaScript 생태계가 있다.

이 에코시스템은 UMD(node.js에서 사용하는 이전 패키지 시스템) 대신 ESM 패키지를 통해 배포되어야 한다. skypack.dev 같은 서비스는 UMD 패키지를 ESM으로 전환함으로써 격차를 줄이는 데 도움이 될 수 있다.

그리고 Rails는 패키지를 통해서가 아니라면 이 패키지에 의존하고 업데이트하는 방법에 대한 답변이 필요하다. json 파일을 npm과 함께 작업한다. 내게 여기 몇 가지 아이디어가 있는데 아직 구체화되지 않았다. 그 사이에 ESM 패키지를 다운로드하여 공급업체/디렉토리에 로컬로 보관할 수 있다.

따라서 이 모든 것이 얼마나 유망한지, 어디에서나 볼 수 있는 ES6, 어디에서나 볼 수 있는 HTTP2 및 import 맵이 결합되어 있지만, 웹팩(그리고 Webpacker)이 필요한 애플리케이션은 분명 있다. 적어도 지금은. 그리고 그건 괜찮다. 우리는 전진하고 있다. 아직 모든 사람에게 가능한 것은 아니지만, 그럴 수 있는 사람들은 크게 기뻐할 것이다.

이 분석의 기본 원칙을 반박하는 새로운 증거가 나타나지 않는 한, Rails 7.0은 가져오기 맵을 기반으로 기본 설정을 제공하는 것을 목표로 하고 웹패커 접근 방식을 선택 사항으로 남겨둘 것이다.

프런트엔드에 대한 단순성 수정은 이미 늦었다. ES6/HTTP2/import 맵이 바로 이 기능을 제공할 것으로 보인다. 만세!

---

원문: [Modern web apps without JavaScript bundling or transpiling](https://world.hey.com/dhh/modern-web-apps-without-javascript-bundling-or-transpiling-a20f2755)
